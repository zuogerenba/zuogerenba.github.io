(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{545:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"一、什么是promise-干嘛的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是promise-干嘛的"}},[e._v("#")]),e._v(" 一、什么是Promise?干嘛的？")]),e._v(" "),a("p",[e._v(": : : tips")]),e._v(" "),a("p",[e._v("Promise是异步编程的一种解决方案：promise是一个对象，可获取异步操作的消息。三种状态：pending,fulfiled,rejected;状态一旦改变，就不会再改变。new Promise会立即执行。其解决了回调地狱，多个请求并发的问题。")]),e._v(" "),a("p",[e._v(": : :")]),e._v(" "),a("h2",{attrs:{id:"二、promise的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、promise的用法"}},[e._v("#")]),e._v(" 二、Promise的用法")]),e._v(" "),a("p",[e._v("Promise是一个构造函数，自己身上有all，reject，resolve这几个眼熟的方法，原型上有catch等方法。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let p = new Promise((resolve, reject) => {\n    //做一些异步操作\n    setTimeout(() => {\n        console.log('执行完成');\n        resolve('我是成功！！');\n    }, 2000);\n});\n")])])]),a("p",[e._v("Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：")]),e._v(" "),a("ul",[a("li",[e._v("resolve ：异步操作执行成功后的回调函数")]),e._v(" "),a("li",[e._v("reject：异步操作执行失败后的回调函数")])]),e._v(" "),a("h3",{attrs:{id:"then-链式操作的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#then-链式操作的用法"}},[e._v("#")]),e._v(" then 链式操作的用法")]),e._v(" "),a("p",[e._v("所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("p.then((data) => {\n    console.log(data);\n})\n.then((data) => {\n    console.log(data);\n})\n.then((data) => {\n    console.log(data);\n});\n")])])]),a("h3",{attrs:{id:"reject的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reject的用法"}},[e._v("#")]),e._v(" reject的用法：")]),e._v(" "),a("p",[e._v("把Promise的状态设置为rejected，这样我们在then中就能捕捉到，然后执行失败的回调。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    let p = new Promise((resolve, reject) => {\n        //做一些异步操作\n      setTimeout(function(){\n            var num = Math.ceil(Math.random()*10); //生成1-10的随机数\n            if(num<=5){\n                resolve(num);\n            }\n            else{\n                reject('数字太大了');\n            }\n      }, 2000);\n    });\n    p.then((data) => {\n            console.log('resolved',data);\n        },(err) => {\n            console.log('rejected',err);\n       \n\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);