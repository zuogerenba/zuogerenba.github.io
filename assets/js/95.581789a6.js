(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{572:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"网易云"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网易云"}},[t._v("#")]),t._v(" 网易云")]),t._v(" "),s("h3",{attrs:{id:"_1-项目介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-项目介绍"}},[t._v("#")]),t._v(" 1.项目介绍")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\t使用了React编写的网易云PC Web项目，接口是来源于开源的项目，所以我觉得这是一个很好的练习项目，这样就可以把精力放在前端上，而不用烦恼数据的来源。\n\t本项目目前为止的话，搭好了项目的骨架。因为里面东西很多，也在陆续开发中，\n\t页面：推荐页面下面的轮播图展示，热门推荐，新碟上架，歌曲排行榜等等。\n\t\n\t业务功能：\n\t\t1.轮播图的滚动。\n\t\t2.点击歌曲，进行播放，并且添加到歌单里面\n\t\t3.根据歌曲的不同播放模式进行播放，随机、顺序、单曲。上一首下一首的播放与暂停。\n\t\t4.拖动进度条可以根据进度条的进度播放对应的位置\n\t\t5.点击播放模式可以更改播放模式，并且做出相应精灵图图标的变化\n\t\t6.歌词的展示\n\t\t\n\t学到的知识点：\n\t\t1.项目规范，项目文件夹划分的规范，变量名小驼峰，组件名大驼峰，常量大写\n\t\t2.写组件，整个项目都采用了函数式组件，并且全面HOOKS\n\t\t3.为了组件的不必要渲染，做了memo的包裹（浅层比较）;\n\t\t4.组件内部状态使用的是useState，useReducer，业务数据都放在redux管理，每个页面都有自己对应的\t\t\t\t  reducer，然后把多个reducer进行合并共享在mian.js里面\n\t\t5.学到了styled-components书写样式，非常方便，嵌套，传参，表达式\n\t\t6.学到了axios的封装，请求相关数据\n\t\t7.学到了antd相关使用，轮播图，展示歌词的message。\n\t\t8.复用性组件的封装。\n")])])]),s("h3",{attrs:{id:"_2-轮播图的滚动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-轮播图的滚动"}},[t._v("#")]),t._v(" 2.轮播图的滚动")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('\t1.轮播图用的是antd里面的走马灯\n\t2.设置了autoplay自动播放\n\t3.用beforechange监听了滚动到哪一张轮播图，并且记录，回调函数(from,to),用useState记录改变\n\t4.监听了下一张上一张轮播图的点击事件。用ref然后bannerRef.current.prev() \n\t5.高斯模糊：url后面拼接相关参数，就可以高斯模糊\n\tconst bgImage = topBanners[currentIndex] && topBanners[currentIndex].imageUrl + "?imageView&blur=40x20"\n')])])]),s("h3",{attrs:{id:"_3-redux存储请求数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redux存储请求数据"}},[t._v("#")]),t._v(" 3.redux存储请求数据")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('1.首先在src/services里面定义相关请求函数并导出；\n2.在reducer里面定义相关的数组或者对象进行存储数据；\n3.在常量文件定义相关常量\n4.在reducer里面case相关常量，并且返回修改数据\ncase actionTypes.CHANGE_TOP_BANNERS:\n      // return {...state,topBanners: action.topBanners} 原有的修改方式性能低\n      return state.set("topBanners", action.topBanners)\n5.在action文件里面定义相关的action， 和dispatch （action）的函数\n6.在组件中使用useEffect/useDispatch对数据进行请求，useSelector对redux进行获取，然后使用。\n')])])]),s("h3",{attrs:{id:"_4-播放功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-播放功能"}},[t._v("#")]),t._v(" 4.播放功能")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("0.拿到歌曲：\n\t1.根据id可以获取到song的相关信息，播放链接，总时长，歌词信息等\n\t2.点击了加入歌单或者播放song的按钮，首先就回去判断歌单里面有没有该歌曲(通过id)，有的话改变currentIndex\n\t3.没有找到的话，就把该歌曲加入到歌单里面，歌单长度+1，同时设置那首歌的songIndex\n\t4.拿到id把audio的src设置为一个链接拼接id的播放链接\n1.使用的是audio标签，还用了antd的slider进度条组件，使用了message展示歌词\n2.有监听了四个播放相关按钮，下一首，上一首，暂停与播放。\n\t1.暂停与播放就是拿到audio的ref然后调用它自带的audioRef.current.pause()/play()\n\t2.上一首下一首传入参数-1/+1，然后dispatch相应的改变currentSong的action\n3.监听进度条\n\t1.请求到的歌曲有总时间duration，\n\t2.onTimeUpdate监听获取到当前时间currentTime，按照比例关系用于展示进度条\n\t3.onEnded可以监听audio播放完，根据他的播放模式去改变当前歌曲，如果是单曲循环的话，currentTime设置为0，\t  重新播放。如果是其他情况，就dispatch相关改变currentSong的action\n4.播放模式\n\t1.单曲循环：进度条玩了后就把currentTime设为0，再play\n\t2.列表循环：\n\t\t1.currentSongIndex+1/-1就行：\n\t\t2.大于边界：currentIndex在最后一首，把currentIndex设为0；\n\t\t3.小于边界，说明current在第一首，上一首的话把currentIndex设为列表length-1\n\t3.随机播放：\n\t\t1.随机生成一个0-length-1的整数，\n\t\t2.while循环判断currentIndex是否等于随机数\n\t\t3.相等继续while循环，不相等就跳出while循环，把currentIndex设为随机数\n")])])]),s("h3",{attrs:{id:"_5-歌词展示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-歌词展示"}},[t._v("#")]),t._v(" 5.歌词展示")]),t._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5C%E9%82%B1%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598697187980.png",alt:"1598697187980"}})]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.歌词是动态歌词展示的，每一个时间点展示对应的歌词，展示在antd里面的message组件里面\n2.根据songId去请求数据，再使用工具类函数对歌词进行解析，得到歌词的数组，里面是对象，时间，content，再通过\tdispatch action将歌词存放在reducer里面，在组件里将其取出来\n3.展示当前歌词\n\t1.拿到所有歌词，是一个数组，数组里面是存放的是对象\n\t2.对象里面time属性代表歌词开始时间，content代表歌词内容\n\t3.用一个for循环，i从0开始，取出歌词列表的time和当前时间作对比\n\t4.当前时间<该歌词的开始时间，那么就应该展示上一句歌词\n2.使用正则将歌词某时间点对应的歌词拿到\n")])])]),s("p",[s("img",{attrs:{src:"C:%5CUsers%5C%E9%82%B1%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598696196089.png",alt:"1598696196089"}})]),t._v(" "),s("h3",{attrs:{id:"_6-项目中的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-项目中的优化"}},[t._v("#")]),t._v(" 6.项目中的优化")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.精灵图\n\t将多张图片合并到一起，减少了http请求，减少了项目中的总体积\n\t\n2.项目全面采用函数式组件开发\n\t1.使用了memo进行了组件包裹，对函数式组件做了优化，避免做一些不必要的渲染。memo内部会对新旧props作比较，\t\t  一样的话。就不会重新渲染，不一样就像渲染；\n\t2.项目中使用了useCallback（将函数缓存）\n\t\t1.第一个参数是函数，第二个是依赖\n\t\t2.场景：回调函数传给子组件使用，如果不使用useCallback就算包裹了memo，父组件更新导致函数重新生成了，\t\t\t引用发生了变化，那么子组件就更新，没必要；所以使用useCallback缓存\n\t\t3.使用：在播放器组件下面的控制器组件里面有一个播放按钮，绑定了播放函数，避免了控制组件的重新渲染。\n\t3.项目中使用useMemo\n\t\t1.返回的也是一个记忆值，依赖不改变，那么记忆值不改变。\n\t\t2.场景：\n\t\t\t是让某个函数在依赖改变的情况下函数运行，避免函数运行的不必要开销\n\n3.使用了ImmutableJs对redux修改进行了优化\n")])])]),s("h2",{attrs:{id:"二、购物商场"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、购物商场"}},[t._v("#")]),t._v(" 二、购物商场")]),t._v(" "),s("h3",{attrs:{id:"_1-项目介绍-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-项目介绍-2"}},[t._v("#")]),t._v(" 1.项目介绍")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.这个项目是使用vue框架开发的移动端项目；因为是移动端，页面的话有首页，分类页，商品详情页，购物车，个人信息等页面\n\t功能：\n\t\t1.轮播图的滚动\n\t\t2.使用了better-scroll，完成上拉加载更多，返回顶部这类的功能\n\t\t3.做了一个tabbar，点击它可以切换流行，热门新款等商品的数据；然后还有吸顶效果\n\t\t4.做了图片的懒加载\n\t\t5.做了底部的导航栏，点击它可以切换到不同的路由\n\t\t6.添加购物车的功能和提交订单\n\t\t\n\t用到的知识点：\n\t\t1.better-scroll\n\t\t2.父子组件的通信，非父子组件的通信；props，emit，eventbus，ref\n\t\t3.vuex进行状态管理，路由相关的知识；\n\t\t4.使用了防抖去优化监听鼠标的滚动事件\n\t\t5.使用了axios请求相关数据\n\t\t6.懒加载\n")])])]),s("h3",{attrs:{id:"_2-轮播图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-轮播图"}},[t._v("#")]),t._v(" 2.轮播图")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\n")])])]),s("h3",{attrs:{id:"_3-better-scroll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-better-scroll"}},[t._v("#")]),t._v(" 3.better-scroll")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.上拉加载\n\t1.本身自带PullingUp监听事件，触发把加载更多的函数emit发射事件出去，调用加载更多的函数，判断当前类型，就\t\t  是把相关数据请求下来加入到对应的数组，去展示\n\t2.再去监听请求下来的图片是否加载完成，然后调用refresh的刷新页面\n\n2.返回顶部\n\t1.在多个页面都使用，首页，详情页，之类需要下滑距离顶部很多的\n\t2.封装了一个复用的返回顶部组件，监听滚动事件，当滚动到一定位置时，就v-show让他展示\n\t3.点击它就会调用backTo函数，传入(0,0)就会返回顶部\n")])])]),s("h3",{attrs:{id:"_4-商品类型栏-吸顶效果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-商品类型栏-吸顶效果"}},[t._v("#")]),t._v(" 4.商品类型栏&吸顶效果")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.商品栏(v-for生成都有index)，三种类型数据，传入不同的index，那个样式就变了，并且展示该index对应的数据，点\t击子组件，就会emit到父组件去调用点击事件，判断传进来的index，记录当前类型就可以了\n\n2.吸顶效果\n\t1.使用了两个商品类型栏(用一个的时候怎么调都掉不出来)。\n\t2.在nav-bar下面放一个同样的商品类型栏，默认v-show为false\n\t3.用bs自带的scroll滚动监听，参数有一个position，根据这个position.y去该组件是否达到顶部\n\t4.到达顶部的话，就让v-show为true就可以了\n\t4.从顶部滑下来，v-show又变为false\n")])])]),s("h3",{attrs:{id:"_5-父子组件-非父子组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-父子组件-非父子组件"}},[t._v("#")]),t._v(" 5.父子组件/非父子组件")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.商品类型栏\n\t商品类型栏是Home组件的子组件，在子组件里面监听点击的index，emit出去点击事件，在Home组件里面展示相关数据\n")])])]),s("h3",{attrs:{id:"_6-图片的懒加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-图片的懒加载"}},[t._v("#")]),t._v(" 6.图片的懒加载")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.使用了vue中的v-lazy，\n2.使用了vant里面的lazyLoad，\n")])])]),s("h3",{attrs:{id:"_7-添加购物车-vuex-提交订单"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-添加购物车-vuex-提交订单"}},[t._v("#")]),t._v(" 7.添加购物车（vuex）/提交订单")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.使用了vuex，将商品的图片，价格等需要在购物车展示的信息存起来，用dispatch出去，然后在actions里面commit到\t   mutations里面\n2.加入购物车前，先判断vuex里面是否已经存在该id了，存在，则把count++再commit进去，没有的话，就设置count=1，   commit进去\n3.展示数据的话就从vuex里面取出来mapGetters，mapMutations，取出相应的数据进行展示\n4.提交订单的话就判断是选中商品，选中才能提交，checkedLength记录选中\n")])])]),s("h3",{attrs:{id:"_8-防抖函数去优化刷新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-防抖函数去优化刷新"}},[t._v("#")]),t._v(" 8.防抖函数去优化刷新")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.因为要去监听图片的加载完成事件，加载完成之后调用refresh()重新计算可滚动区域高度，图片需要展示，\n2.如果不用防抖优化的话，就会页面就会一直不停刷新，造成页面卡顿，用户体验差；\n")])])]),s("h3",{attrs:{id:"_9-上拉加载更多"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-上拉加载更多"}},[t._v("#")]),t._v(" 9.上拉加载更多")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.better-scroll是有监听上拉事件的，监听pullingUp。然后在scroll组件里面发射$emit事件至Home页面里。在home页面里再去调用请求接口，将页码值+1，最终把结果加到我们的商品数组中。注意的点是，我们需要再这个方法里面调用finishPullingup，才能使得下一次加载成功。\n")])])]),s("h2",{attrs:{id:"三、文案中心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、文案中心"}},[t._v("#")]),t._v(" 三、文案中心")]),t._v(" "),s("h3",{attrs:{id:"_1-项目介绍-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-项目介绍-3"}},[t._v("#")]),t._v(" 1.项目介绍")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.因为我们部门是前端国际化的，所以我们为了方便管理不同国家的文案，做了这么一个项目，这个项目主要是针对于文案管理的，可以查看翻译的文案是否通过、还是在审核中，也具有搜索功能，PM具有审批权限，查看文案列表，数据导出等功能，这个项目是5个人一起开发的。\n")])])]),s("h3",{attrs:{id:"_2-年度报告"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-年度报告"}},[t._v("#")]),t._v(" 2.年度报告")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.我是12月1日入职的，正好碰上年末，当时要出一个类似于网易云音乐的那种年度报告，就是你在这一年里做了哪些事情，把数据进行展示，比如你今年做了多少个需求，你延期率是多少啊，主要的原因有哪些，你审批了多少文案等等，把这些数据进行展示给前端，后端，和产品。\n2.里面有四个页面，分别是首页，数据页，故事页，结尾祝福页。\n")])])]),s("h3",{attrs:{id:"_2-门户网站"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-门户网站"}},[t._v("#")]),t._v(" 2.门户网站")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("是一个我们部门的组件库的首页，主要内容有首屏介绍，\n")])])]),s("h3",{attrs:{id:"_3-其他需求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-其他需求"}},[t._v("#")]),t._v(" 3.其他需求")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("一开始熟悉项目的时候，先是以修改需求为主，比如说这个Table页面新增一个下载按钮，将数据导出到Excel里面。或者新建一个筛选选项，将数据筛选出来。后面开始开发相关页面，比如说，新增文案类表页面，点击文案Key跳转至相关的文案列表页面。\n")])])]),s("h3",{attrs:{id:"_4-收获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-收获"}},[t._v("#")]),t._v(" 4.收获")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("typescript和git多人开发的应用。\n之前在涂鸦的时候，有自己的组件库，也不是多人开发模式，自己一个人做一个小项目。所以对git多人开发和组件封装能力提升的不够，在滴滴国际化部门没有组件库，也是多人开发模式，自己慢慢培养了封装组件的能力，数据抽离的能力，对git很多命令，React许多知识点得到了实践，并且发现了很多细节相关的问题，经过一段时间的应用，不再是停留于纸上谈兵的阶段，而是真真正正的应用到实际项目上，给别人使用。也学会了自己总结知识点，难点。\n\n在滴滴的实习，提升的不仅仅是技术方面，沟通能力方面我导师也教会了我许多，如何去更高效的沟通。\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("很可惜，学校并不是一流大学，走到现在都是通过不断学习不断积累起来的。\n平时学习基础知识不断思考总结，并记录在个人博客上。\n自己做项目遇到的难点，实习期间遇到的难点，都会在博客上记录下来。\n平时哪里做的不够好，犯过的错误都会进行反思，分析原因。\n博客从去年5月建立至今，始终保持着更新的状态。\n数据结构与算法相对良好，LeetCode至今144题。\n技术栈相对齐全，React，Vue，Node均做过项目，擅长React，并阅读过部分源码。\n")])])]),s("h2",{attrs:{id:"四、涂鸦智能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、涂鸦智能"}},[t._v("#")]),t._v(" 四、涂鸦智能")]),t._v(" "),s("h3",{attrs:{id:"_1-遇到的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-遇到的问题"}},[t._v("#")]),t._v(" 1.遇到的问题")]),t._v(" "),s("h4",{attrs:{id:"_1-图片无法在不同机型上展示模糊"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-图片无法在不同机型上展示模糊"}},[t._v("#")]),t._v(" 1.图片无法在不同机型上展示模糊")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("由于各种机型上面的分辨力像素不一样，例如IPhone4为320px使用一倍图，375px使用二倍图，才能展示的更加清晰。如果只使用一倍图的话，那么不同机型上面展示必然会变得模糊，解决方案是UI返回二倍图三杯吐，导入的时候进行适配即可\n")])])]),s("h4",{attrs:{id:"_2-调节亮度的sliderbar无法时事更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-调节亮度的sliderbar无法时事更新"}},[t._v("#")]),t._v(" 2.调节亮度的sliderBar无法时事更新")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("由于是云端获取的亮度数据，1-100的亮度值，但是进行滑动的时候产生了一个问题：无法时实更新控制面板上的亮度百分比数据。\n\t原因：将云端数据直接获取展示在组件上面，当然不会进行时实更新。\n\t解决：将云端的数据保存在state内部，再将使滑动组件里面使用内部state数据，再去监听滑动事件，将更新情况上传至云端即可。\n")])])]),s("h4",{attrs:{id:"_3-很多css3属性无法使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-很多css3属性无法使用"}},[t._v("#")]),t._v(" 3.很多css3属性无法使用")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("像box-shadow无法使用，最后去网上搜索进行解决\n")])])]),s("h4",{attrs:{id:"_4-内部组件库无法满足需求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-内部组件库无法满足需求"}},[t._v("#")]),t._v(" 4.内部组件库无法满足需求")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("内部组件库里面是有Topbar这个组件的，但是我做这个项目的时候需求和组件库里面的组件不一样，一般topBar有三个板块，左边返回操作，中间这是你还title信息，右边有一些编辑，更多等的一些操作。但是我的这个智能插座的需求时有副标题的，展示一些倒计时多少分钟会开机、关机等信息。\n解决：最后通过传入subTitle这个props，在里面写好对应的样式进行展示即可。\n")])])]),s("h3",{attrs:{id:"_2-杂项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-杂项"}},[t._v("#")]),t._v(" 2.杂项")]),t._v(" "),s("h4",{attrs:{id:"_1-开发流程-打包流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-开发流程-打包流程"}},[t._v("#")]),t._v(" 1.开发流程，打包流程")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.导师分配任务，创建好项目模板。\n2.查看需求文档，和产品对好需求。\n3.开发项目，开发完之后对不同机型进行测试，包括安卓端和iOS端。\n4.按照规范提交代码，申请合并代码，并且把代码给导师review。\n5.提交发布单填写产品的UIID和pid，产品信息等，填写完就导师审批后就可以点击打包按钮进行打包。\n")])])]),s("h4",{attrs:{id:"_2-项目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-项目描述"}},[t._v("#")]),t._v(" 2.项目描述")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("这家公司做的产品是智能家居的控制面板，像智能灯，智能床，智能空调等等，一个人负责一个产品，项目名称是UIID，使用的时React Native\n")])])]),s("h2",{attrs:{id:"实习经历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实习经历"}},[t._v("#")]),t._v(" 实习经历")]),t._v(" "),s("h3",{attrs:{id:"_1-滴滴"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-滴滴"}},[t._v("#")]),t._v(" 1.滴滴")]),t._v(" "),s("h4",{attrs:{id:"_1-使用cookie-localstorage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用cookie-localstorage"}},[t._v("#")]),t._v(" 1.使用cookie，localStorage")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("cookie:\n\t当时有一个需求是如果当前用户去通过一个文案审批，但是这个用户不是修改文案的人，就不一致，那点击通过的时候就会展示不同的弹窗，一般情况是会问你是否通过，修改人审批人不一致，就是“当前文案不是你修改的，是否通过？”，那就需要把当前用户名取出来，cookies.SSO_I18N_USERNAME，和当前修改人作对比了。\n\nlocalStorage：\n\t当时我负责年度报告的开发，其中有一个需求是这样的：在圣诞节那一天，第一次进入我们的文案中心网站，就需要弹出一个圣诞老人图片，点击即可进入年度报告页面。第二次进入就需要手动进入，不展示弹窗。\n\t那么就在localStorage.setItem('firstFlag', 'false');建立一个Item，记录是否是第一次进入这个年度报告页面。\n")])])]),s("h4",{attrs:{id:"_2-手动封装复用性组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-手动封装复用性组件"}},[t._v("#")]),t._v(" 2.手动封装复用性组件")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("比如，在当时做技术门户网站的首页时，去展示我们部门应用app，按照分类大概有及时个的时候，都是一样固定的格式，于是就把它封装起来。还有我们部门同事写的文章介绍组件，里面有标题，部分内容，作者，发布日期等信息，首页上面有9篇文章介绍，将他们封装起来，最后动态传入props信息，可以进行复用。\n")])])]),s("h3",{attrs:{id:"_3-cdn-base64"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-cdn-base64"}},[t._v("#")]),t._v(" 3.CDN，base64")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("在之前自己开发项目的时候，图片等资源都是使用本地导入的方式。现在图片资源都是上传静态资源服务器里面，会生成一个链接，在img标签里面引用即可。对于有些图片，例如小图标，指引，帮助，年度报告入口图标，都是使用base64去展示的。\n")])])]),s("h4",{attrs:{id:"_4-抽离公共代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-抽离公共代码"}},[t._v("#")]),t._v(" 4.抽离公共代码")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1.当时突然很多个页面都需要添加下载按钮，做导出数据至Excel功能。于是将下载按钮样式的代码抽离值全局，再进行使用，样式方面就只需要进行写一下类名即可，点击事件方面，抽离下载事件的代码至工具类库，获取到下载链接之后，传入相应的downUrl即可下载。\n")])])]),s("h4",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=r.exports}}]);