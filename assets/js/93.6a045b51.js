(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{566:function(e,n,t){"use strict";t.r(n);var o=t(42),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\t自4G时代以来，互联网迎来了飞速的发展，各大公司业务突飞猛进，近十年来新诞生了一个又一个类似美团，拼多多，字节跳动这样的互联网巨头，现代人们的衣食住行已经离不开这些互联网的APP了，国内大量的用户使用这些软件，给这些公司带来巨大的财富收益，计算机行业也成为了高薪行业，从而吸引了大量的人才成为程序员。那么针对于某些群体的交流平台的作用是显而易见的，比如针对于相亲群体，不管是线上还是线下都会有一个交流平台，线下的公园角，线上的相亲网站。又比如针对于学习英语的群体，线上有学习英语的网站，线下有英语协会。所以，针对于程序员这个群体，存在一个交流平台帮助他们学习，获取一些工作相关的信息是非常有必要的。\n\t相对于线下的交流平台，一个线上的交流平台有着巨大的优点，比如，线下交流平台最多只能聚集该城市的程序员，数量上有一定的局限性，而线上平台，你只要通过注册登录就可以加入该平台，可以聚集全国，甚至全世界的程序员；另一方面，程序员的水平参差不齐，在线下，你去听这个程序员分享技术知识，花了时间去听，回来查阅资料发现他讲的有些内容并不是很严谨，从而浪费了自己的时间，而在线上，你可以通过查看点赞数筛选出高质量程序员中的高质量文章进行学习，从而将获取知识的效率提高的最大化；再比如，你想从这个城市换工作到另外一个城市去，通过线下交流，几乎不可能获取到另外一个城市相关的工作信息，但是通过线上的交流平台，你可以在内推模块中查阅相关信息。一个线上的程序员交流平台对于程序员来说就显得尤为重要了，本交流平台本着高度用组件，前后端分离的原则，本交流平台设计了四大模块：\n\t文章的发表与阅读模块，文章发表是用于登录后的程序员书写，然后调用接口存入MySQL中的文章表中，阅读是在前端页面生命周期挂载阶段就调用请求文章列表的接口请求到数据之后展示，登录的用户可以进行点赞等操作。\n\t内推模块，内推模块由一般用于想赚取内推奖金的员工，公司专门负责招聘的HR发表，由想找工作的程序员去阅读，找到心仪的岗位可以通过内推信息上的联系方式联系内推人进行投递简历。\n\t问答模块，问答模块由登录用户进行发表问题提问，由其他用户进行回答，提问的问题不局限于技术方面的，本平台的宗旨是为程序员解决问题的，所以对于生活方面的问题也可以进行提问，比如可以在上面对某一家公司的加班情况进行提问。\n\t新闻模块，可以查看互联网届的新闻的动态。\n\t本交流平台在技术上采用了前后端分离的思想，前端是JavaScript中的React框架作为前端框架，后端是Node中的Koa框架，数据库采用的是MySQL，使用axios这个库在前端中向后端发起相关接口请求；使用了散列算法对注册用户的密码进行加密，从而保证了密码的安全性；使用了Token+Cookie的技术对登录用户进行持久化登录与鉴权操作，让用户不用每做一次操作就需要登录，携带Token即可，提高了性能；在后端中数据库与MySQL的连接使用了mysql2，并且使用了预处理语句提高sql语句的执行效率，也防止黑客进行SQL注入攻击。\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Since the 4G Era, the Internet has ushered in rapid development, the business of major companies is advancing by leaps and bounds, In the past decade, Internet giants like meituan, pinduoduo and bytedance have emerged one after another. The modern people's clothing, food and living are inseparable from the app of the Internet, a large number of domestic users use these software, bring huge wealth to these companies, the computer industry has also become a high wage industry, thus attracted a large number of talents to become programmers. So the role of communication platform for certain groups is obvious. For example, for blind date groups, Whether online or offline, there will be a communication platform, offline Park Corner, online dating website; For example, for the group learning English, there are websites for learning English online and English associations offline.Therefore, for programmers, it is necessary to have a communication platform to help them learn and obtain some work-related information.\nCompared with the offline communication platform, an online communication platform has great advantages, For example, offline communication platforms can only gather programmers in the city at most, which has certain limitations in number, And online platform, you can join the platform only by registering and logging in, which can gather programmers from all over the country or even the world; On the other hand, the level of programmers is uneven. Offline, you go to listen to the programmer to share technical knowledge, spend time listening to it, come back to the data and find that some of the contents he talks about are not very rigorous, which wastes your time. On the online, you can select high-quality articles from high-quality programmers through the number of reviews to learn, Thus, the efficiency of knowledge acquisition will be maximized. For another example, if you want to change your job from this city to another city, it is almost impossible to obtain the relevant work information of another city through offline communication, but through the online communication platform, you can check the relevant information in the internal push module; An online communication platform for programmers is particularly important for programmers. Based on the principle of highly using components and separating front and back ends, this communication platform has designed four modules: \nThe publication and reading module of the article is published by the programmer after logging in, and then the interface is stored in the article table in MySQL. Reading is the interface request to the requested article list in the front page lifecycle mounted stage, and it shows that the user who can login can do some praise.\nInternal push module, which is generally used for employees who want to earn internal push bonus, is published by HR who is specially responsible for recruitment in the company. Programmers who want to find a job can read it and find the desired position. They can contact the internal push person through the contact information on the internal push information to deliver their resume.\nThe Q & a module is used by login users to issue questions and other users answer them. The questions are not limited to technical aspects. The purpose of this platform is to solve problems for programmers. Therefore, questions about life can also be asked. For example, overtime of a company can be asked above.\nNews module, you can view the news of the Internet.\nThe front end is the react framework in JavaScript as the front-end framework, the back end is the koa framework in node, and the database is mysql. Axios is used to send related interface requests to the back-end in the front-end; Hash algorithm is used to encrypt the registered user's password to ensure the security of the password; The technology of token + cookie is used for persistent login and authentication of login users, so that users don't need to login every time they do an operation, and they can carry the token, which improves the performance; In the back end, mysql2 is used to connect the database and MYSQL, and preprocessing statements are used to improve the efficiency of SQL statements, and prevent hackers from SQL injection attacks.\nKey words: Programmer communication platform;Separation of front and rear ends;React; Node;MySql; Performance optimization\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 1.前端提交账号密码\nhandleLoginBtn(e) {\n    const username = document.getElementById("name").value;\n    const pwd = document.getElementById("pwd").value;\n    userLogin(username, pwd).then((res, err) => {\n        message.success(\'登陆成功\');\n        localStorage.setItem(\'login\', res.data && res.data.token)\n        e.preventDefault();\n        const action = actionCreators.getLoginAction(true);\n        dispatch(action);\n        // 登录后显示滚动条\n        document.documentElement.style.overflowY = "scroll";\n    }).catch(err => {\n        message.error(\'登陆失败\');\n    })\n    \n// 验证登录密码\nconst verifyLogin = async (ctx, next) => {\n  // 1.获取用户名密码\n  const { name, password } = ctx.request.body;\n  // 2.判断用户名密码是否为空\n  if (!name || !password || name === \'\' || password === \'\') {\n    // 处理错误类型的时候不应该每一个写死，应该定义常量\n    const error = new Error(errorTypes.NAME_OR_PASSWORD_IS_REQUIRED);\n    return ctx.app.emit(\'error\', error, ctx);\n  }\n  // 3.判断用户是否存在\n  const result = await service.getUserByName(name);\n  const user = result[0];\n  // 是一个数组，有长度就代表存在\n  if (!user) {\n    const error = new Error(errorTypes.USER_NOT_EXISTS);\n    return ctx.app.emit(\'error\', error, ctx);\n  }\n  // 4.判断密码是否匹配\n  // 因为两个使用的时相同的加密算法，所以获取到数据库查询到的password用同样的加密算法进行比较\n  const { PASSWORD } = result[0];\n  console.log(PASSWORD,result)\n  const inputPassword = md5password(password);\n  if (result[0].password !== inputPassword) {\n    const error = new Error(errorTypes.ERROR_PASSWORD);\n    return ctx.app.emit(\'error\', error, ctx);\n  }\n  console.log("登陆成功")\n  ctx.user = user;\n  await next();\n}\n\n// 3.生成token代码\n/**\n* @description 非对称性加密生成token\n* @param {*} ctx \n* @param {*} next \n*/\nasync login(ctx, next) {\n    const { id, name } = ctx.user;\n    const token = jwt.sign({ id, name }, PRIVATE_KEY, {\n      expiresIn: 60 * 60 * 24,\n      algorithm: "RS256"\n});\n\nctx.body = {\n  id,\n  name,\n  token\n};\n}\n\n<StyledUserCollection>\n    <CollectionNav>\n        {/* 选中区块的底部蓝色滑块 */}\n        <BlueSlide className="blue-slide" position={getPositionOfSelectBox(collectionType)} />\n        <NavLink\n            className="activities"\n            isActive={(match) => {\n                // url 参数没有的情况，默认为 activities\n                if (match || collectionType === undefined) {\n                    return true;\n                }\n            }}\n            to={"/userpage/" + params.id + "/activities"}\n            onClick={props.clearCollectionList}>\n            动态\n        </NavLink>\n        <NavLink\n            className="articles"\n            to={"/userpage/" + params.id + "/articles"}\n            onClick={props.clearCollectionList}>\n            文章\n        </NavLink>\n        <NavLink\n            className="favorites"\n            to={"/userpage/" + params.id + "/favorites"}\n            onClick={props.clearCollectionList}>\n            收藏\n        </NavLink>\n        <NavLink\n            className="likes"\n            to={"/userpage/" + params.id + "/likes"}\n            onClick={props.clearCollectionList}>\n            <span>赞 </span>\n            <span className="number">\n                {"17.2k"}\n                <i className="iconfont">&#xe629;</i>\n            </span>\n        </NavLink>\n        <NavLink\n            className="comments"\n            to={"/userpage/" + params.id + "/comments"}\n            onClick={props.clearCollectionList}>\n            评论\n        </NavLink>\n    </CollectionNav>\n    <main>\n        {getCollections()}\n    </main>\n</StyledUserCollection>\n\nexport const Articles = (props) => {\n\n    const cancelTokenSourceRef = useRef(axios.CancelToken.source());\n\n    useEffect(() => {\n        const cancelTokenSource = cancelTokenSourceRef.current;\n        const func = props.getInitialHomepageData;\n        func(cancelTokenSource);\n        return (() => {\n            cancelTokenSource.cancel("中止首页文章的异步请求");\n        });\n    }, [props.getInitialHomepageData, cancelTokenSourceRef])\n\n    // 每次进入主页时清空列表，不然还保留着上次的文章记录\n    // 不过即使不要下面这段，数据依然会更新就是了，只是说更新前还会保持原来的数据\n    useEffect(() => {\n        const func = props.clearArticleList;\n        func();\n    }, [props.clearArticleList])\n\n\n    let element;\n    if (props.articleList.size === 0) {\n        element = (<Loading />);\n    } else {\n        element = (\n            <StyledArticles>\n                <ul>\n                    {props.articleList.map((article) => {\n                        return (\n                            <Article\n                                key={article.get("id")}\n                                id={article.get("id")}\n                                author={article.get("author")}\n                                time={article.get("time")}\n                                tag={article.get("tag")}\n                                title={article.get("title")}\n                                desc={article.get("desc")}\n                                titlePicUrl={article.get("titlePicUrl")}\n                            />\n                        );\n                    })}\n                </ul>\n                {/* 加载更多 */}\n                {props.loading\n                    ? (\n                        <MoreArticlesLoadingAnimation>\n                            <i className="iconfont">&#xe668;</i>\n                        </MoreArticlesLoadingAnimation>\n                    )\n                    : (<MoreArticles onClick={props.handleLoadMoreClick}>加载更多···</MoreArticles>)\n                }\n            </StyledArticles>\n        );\n    }\n\n    return element;\n}\n\n\n\nexport const Write = (props) => {\n\n    const dispatch = useDispatch();\n\n    // 去掉最外层的滚动栏\n    useEffect(() => {\n        document.documentElement.style.overflowY = "hidden";\n        return () => {\n            document.documentElement.style.overflowY = "scroll";\n        }\n    }, [])\n\n    // 清空文章数据\n    useEffect(() => {\n        return () => {\n            dispatch(getChangePreviewAction(""));\n        }\n    }, [dispatch])\n\n    // 实时渲染\n    const editRef = useRef(null);\n    const previewRef = useRef(null);\n    function handleInstantRender(e) {\n        dispatch(getChangePreviewAction(e.target.innerText));\n        handleEditScroll();\n    }\n    // 同步滚动\n    function handleEditScroll() {\n        const editContentHeight = editRef.current.scrollHeight;\n        const editContainerHeight = editRef.current.offsetHeight;\n        const previewContentHeight = previewRef.current.scrollHeight;\n        const previewContainerHeight = previewRef.current.offsetHeight;\n        const scale = (previewContentHeight - previewContainerHeight) / (editContentHeight - editContainerHeight);\n        // 当右方不能滚动的时候，计算scale的分母会为0，scale会为 infinity 或者 NaN（分子分母都为0），不过反正此时也没必要滚动\n        if (scale) {\n            const previewPosition = (editRef.current.scrollTop * scale);\n            previewRef.current.scrollTo(0, previewPosition);\n        }\n    }\n\n    let element;\n    if (!props.loginStatus) {\n        // 未登录的时候，通过更改网址进入到这个页面的时候\n        element = (\n            <div style={{ marginTop: "61px" }}>您还没有登录</div>\n        );\n    } else {\n        element = (\n            <StyledWrite>\n                <div\n                    className="edit"\n                    contentEditable="plaintext-only"\n                    spellCheck={false}\n                    // 防抖\n                    onInput={debounce(handleInstantRender, 200)}\n                    onScroll={handleEditScroll}\n                    // 关闭 grammarly\n                    data-gramm={false}\n                    ref={editRef}\n                ></div>\n                <div className="preview" ref={previewRef}>\n                    <ReactMarkdown\n                        source={props.previewContent}\n                        plugins={[gfm]}\n                        renderers={renderers}\n                        allowDangerousHtml\n                    />\n                </div>\n            </StyledWrite>\n        );\n    }\n    return element;\n}\n\n\nclass commnetController {\n  // 添加评论\n  async createComment(ctx, next) {\n    console.log(\'来到评论控制器~\')\n    // 1.获取参数\n    const { content, momentId } = ctx.request.body;\n    const { id } = ctx.user;\n    // 2.执行SQL语句\n    const result = await commentService.create(content, momentId, id);\n    // 3.返回结果\n    ctx.body = result;\n  }\n\n  // 回复评论\n  async reply(ctx, next) {\n    const { content, momentId } = ctx.request.body;\n    const { commentId } = ctx.params;\n    const { id } = ctx.user;\n    const result = await commentService.reply(momentId, content, id, commentId);\n    ctx.body = result;\n  }\n\n    // 修改评论\n    async modify(ctx, next) {\n      const { content } = ctx.request.body;\n      const { commentId } = ctx.params;\n      const result = await commentService.modify(content, commentId);\n      console.log(\'aa\')\n      ctx.body = result;\n    }\n\n    // 删除评论\n    async remove(ctx, next) {\n      const { content, momentId } = ctx.request.body;\n      const { commentId } = ctx.params;\n      const { id } = ctx.user;\n      const result = await commentService.reply(momentId, content, id, commentId);\n      ctx.body = result;\n    }\n}\n')])])]),t("ul",[t("li",[t("p",[e._v("用户登录逻辑图")])]),e._v(" "),t("li",[t("p",[e._v("数据表可以加东西")])]),e._v(" "),t("li",[t("p",[e._v("技术介绍可以加东西")])]),e._v(" "),t("li",[t("p",[e._v("第五章模块实现可以加东西")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 1.交流体现在哪里？\n\t发布内容-评论-回复\n// 2.评论表怎么设计？\n\t1.评论单独放一个表，里面存储了回复相关内容\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);